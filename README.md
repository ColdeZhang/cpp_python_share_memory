# cpp_python_share_memory
 c++与python共享内存实现

## 基本原理

共享内存实际上就是进程通过调用shmget（Shared Memory GET 获取共享内存）来分配一个共享内存块，然后每个进程通过shmat（Shared Memory Attach 绑定到共享内存块），将进程的逻辑虚拟地址空间指向共享内存块中。 随后需要访问这个共享内存块的进程都必须将这个共享内存绑定到自己的地址空间中去。当一个进程往一个共享内存快中写入了数据，共享这个内存区域的所有进程就可用都看到其中的内容。

因为所有进程共享同一块内存，共享内存在各种进程间通信方式中具有最高的效率。访问共享内存区域和访问进程独有的内存区域一样快，并不需要通过系统调用或者其它需要切入内核的过程来完成。同时它也避免了对数据的各种不必要的复制。

<img src="https://s2.loli.net/2022/06/30/aNf3ThZxFCrRuA2.png" alt="image-20220630215333671" style="zoom:50%;" />

1. 共享内存是进程间共享数据的一种最快的方法。一个进程向共享的内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。
2. 使用共享内存要注意的是多个进程之间对一个给定存储区访问的互斥。若一个进程正在向共享内存区写数据，则在它做完这一步操作前，别的进程不应当去读、写这些数据。

> 系统内核没有对访问共享内存进行同步，C++也没有提供相应的互斥机制，必须手动实现同步。

## 跨语言构建思路

1. c++编译动态库完成各种共享内存的实际操作。
2. python/c++端调用动态库进行共享内存数据交互。

<img src="https://s2.loli.net/2022/06/29/W5smZ7wUlvqL1eh.png" alt="image-20220629164418833" style="zoom:50%;" />

兼容 c++与python、c++与c++、python与python 任意 一对一 之间的跨进程大容量数据传输。



## 提高效率的实现细节

### 1.利用Unix系统的信号（Signal）实现应答；

<img src="https://s2.loli.net/2022/07/05/jNP2gCSvJapFUWL.png" alt="image-20220705170524349" style="zoom:90%;" />

- 利用信号作为应答，解决了双端死循环造成的资源占用高问题；

- 可以接受传回复杂数据，同时几乎不增加额外的耗时；

- 调用简易，形式上将接收端封装成了CallSlave()函数；

### 2.使用多线程并行写入内存，大幅提高写入速度；

<img src="https://s2.loli.net/2022/07/05/EBAaHR1mIYNCrwi.png" alt="image-20220705162946661" style="zoom:50%;" />

- 发送端将要发送的数据进行拆分，使用多线程同时写入共享内存中；

- 理论上将数据拆分为n份可以提高写入速度n倍；

- 由于读取内存数据耗时几乎可以忽略不计，因此整段读取；



## 快速使用方法

### C++

```cmake
# CMakeList.txt

# 编译生成 libsharememory.so 动态库
add_library(sharememory SHARED src/share_memory.h src/share_memory.cpp)

# 将共享内存加入项目
add_executable(cpp_python
        test.cpp
        src/share_memory.cpp src/share_memory.h)
```

使用方法：

```c++
// 1.引入头文件
#include "share_memory.h"

// 2.创建共享内存
ShareMem::ShareMemory ShareImpl(12331);

// 3.设置图片的长、宽、通道信息
ShareImpl.SetShareHead(img_rows, img_cols, img_channels);

// 4.写入图片，支持多线程（最大不超过4）
ShareImpl.WriteData(data_start_address, data_size, offset, threads);

// 5.调用CallSlave()直接获取微服务的结果
ShareImpl.CallSlave()
```



### Python

共享内存功能已经封装为可调用的python模块，模块目录结构如下：

```
─┬	PyShareMemor
 ├──	__init__.py
 ├──	ShareMemory.py
 └──	libsharememory.so
```

模块调用示例：

```python
# 将模块放在项目根目录，导入共享内存模块
from PyShareMemory.ShareMemory import ShareMemory

# 创建共享内存，参数为共享内存的识别key
share = ShareMemory(12331)

# 传入ai计算任务函数，假设ai函数是 engine.inference_v2(img, imgW, imgH)
# 函数的返回必须要是字符串
share.do(engine.inference_v2)

# 让程序保持存活，等待收到信号
while(True):
    print("[Python]: ++++++++++心跳包，表明程序活着++++++++++")
    time.sleep(5)
```

> ShareMemory类的其他方法：详见模块内的注释。


## 性能测试

### 测试平台

- OS: CentOS Linux 7 (Core) x86_64
- Host: Intel Corporation 440BX Desktop
- Kernel: 3.10.0-1160.el7.x86_64
- CPU: Intel Xeon Gold 6226R (20) @ 2.893G
- Memory: 64245MiB
- g++ (GCC) 8.3.1 20190311 (Red Hat 8.3.1-3)
- Python 3.8.8

### 测试方法

- 统计结果均为平均耗时，即发送多张图片用总耗时除以发送次数（100次），由于最初建立通信的前两次传输不稳定，因此计算时时舍弃了前两帧；

- 发送的数据：由OpenCV生成的三通道彩色标准BGR图片；

- 返回的数据：接收完成的标志位（一个整形变量）；

- 仅使用一个线程；

| 尺寸             | 大小（MB） | 发送耗时*（ms） | 收发耗时*（ms） | 传输效率（大小/收发耗时）MB/ms |
| ---------------- | ---------- | --------------- | --------------- | ------------------------------ |
| 640*640          | 1.17       | 0.20            | 0.21            | 5.57                           |
| 640*640 （4张）  | 4.68       | 0.66            | 0.67            | 6.99                           |
| 640*640 （8张）  | 9.37       | 1.33            | 1.34            | 6.99                           |
| 640*640 （16张） | 18.75      | 3.01            | 3.03            | 6.19                           |
| 720*360          | 0.74       | 0.11            | 0.12            | 6.17                           |
| 1920*1080        | 5.93       | 0.88            | 0.89            | 6.66                           |
| 1920*1080（4张） | 23.73      | 4.07            | 4.09            | 5.80                           |
| 1920*1080（8张） | 47.46      | 8.55            | 8.56            | 5.54                           |
| 极限大小         | 2002.71    | 367.74          | 367.79          | 5.45                           |

> **发送耗时：**相当于数据c++写入共享内存的耗时，统计的时间为**c++端的写入耗时**；
>
> **收发耗时：**接收数据时会对上一次发送作校验，只有在上一次发送的数据被python端接收处理并返回处理成功的信息后才会发送下一帧。统计的时间为**第n帧开始发送的时间**至**第n+1帧发送前的时间**；

- 以传输 32 张 640*640 图片（37.5MB）为例，测试多线程传输，其余条件不变：

| 线程数 | 发送耗时（ms） | 收发耗时（ms） | 传输效率（大小/收发耗时）MB/ms |
| ------ | -------------- | -------------- | ------------------------------ |
| 1      | 7.58           | 7.75           | 4.83                           |
| 2      | 3.82           | 3.94           | 9.51                           |
| 3      | 2.41           | 2.55           | 14.7                           |
| 4      | 2.13           | 2.25           | 16.6                           |




## 定制化数据传输

